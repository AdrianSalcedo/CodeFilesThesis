}
# Test / debug the model
test = sampling(m3, data = flu_data, pars = parameters_stoch, init = ini_3, chains = 1, iter = 10)
time.start_nuts3 <- Sys.time()
nuts_fit_3 = sampling(m3, data = flu_data, pars = parameters_stoch, init = ini_3, chains = n_chains, warmup = n_warmups, iter = n_iter, thin=n_thin, seed=13219)
time.end_nuts3 <- Sys.time()
duration_nuts3 <- time.end_nuts3 - time.start_nuts3
nuts_fit_3_summary <- summary(nuts_fit_3, pars = c("lp__", "theta[1]", "theta[2]", "y_init[1]", "R_0", "phi", "s_sq"))$summary
print(nuts_fit_3_summary,scientific=FALSE,digits=2)
print(duration_nuts3)
posts_3 <-  rstan::extract(nuts_fit_3)
mod3_diagnostics <-rstan::get_sampler_params(nuts_fit_3)
# Check for divergent transitions
rstan::check_divergences(nuts_fit_3)
posterior_3 <- as.array(nuts_fit_3)
# Markov chain traceplots
mcmc_trace(posterior_3, pars="lp__")
mcmc_trace(posterior_3, pars=c("theta[1]", "theta[2]", "y_init[1]"))
mcmc_trace(posterior_3, pars=c("phi","s_sq"))
mcmc_trace(posterior_3, pars="R_0")
pairs(nuts_fit_3, pars = c("theta[1]", "theta[2]", "y_init[1]", "phi","s_sq"), labels = c("beta", "gamma", "s(0)", "phi", "s_sq"),
cex.labels=1.5, font.labels=9, condition = "accept_stat__")
mcmc_dens_overlay(posterior_3, pars=c("theta[1]", "theta[2]", "y_init[1]", "phi","s_sq"))
mcmc_intervals(posterior_3,pars = c("theta[1]", "theta[2]", "y_init[1]", "phi","s_sq"))
# Model fitted values
fit_lambda <- posts_3$lambda
post_kappa <-posts_3$kappa
fit_kappa <- unlist(post_kappa)
fit_I_3 <- posts_3$y_hat[,,2]
fit_SIR_3 <- fit_I_3*pop
post_mu <- log(fit_I_3*pop)
fit_mu <- unlist(post_mu)
fit_phi <- posts_3$phi
fit_sigma <- posts_3$sigma
mean_lambda <- matrix(nrow=10000, ncol=14)   # mean of Poisson parameter
mean_lambda[,1]=exp(fit_mu[,1]+(fit_sigma/2));
for (i in 2:N){
mean_lambda[,i]=exp(fit_mu[,i]+(fit_kappa[,i-1]-fit_mu[,i])*exp(-fit_phi) +(fit_sigma/2));
}
median_lmean = apply(mean_lambda, 2, median)
low_lmean = apply(mean_lambda, 2, quantile, probs=c(0.025))
high_lmean = apply(mean_lambda, 2, quantile, probs=c(0.975))
df_fit_lmean = data.frame(median_lmean, low_lmean, high_lmean, sample_time)
load("df_I_det_Poiss.Rda") # fitted values from the deterministic model
median_I<-df_fit_I_1$median_I_1
low_I<-df_fit_I_1$low_I_1
high_I<-df_fit_I_1$high_I_1
df_fit_I = data.frame(median_I, low_I, high_I, sample_time)
# Plot of the data along with the fitted mean of Poisson parameter and the fitted number of infected from the deterministic model
ggplot(df_sample_N, aes(x=sample_time, y=cases)) +
geom_ribbon(aes(x=sample_time, ymin = low_lmean, ymax = high_lmean), fill = "lightblue", alpha = 0.6) +
geom_ribbon(aes(x=sample_time, ymin = low_I, ymax = high_I), fill = "orange", alpha = 0.6) +
geom_line(data = df_fit_lmean, aes(x=sample_time, y=median_lmean, color="Fitted stochastic model"),size = 1.3) +
geom_line(data = df_fit_I, aes(x=sample_time, y=median_I, color = "Fitted deterministic model"), size = 1.3) +
geom_point(shape = 19, size = 3, (aes(color="Data"))) +
scale_colour_manual(name='', values=c('Data'='black', 'Fitted stochastic model'='lightblue4', 'Fitted deterministic model'='darkorange3'))+
guides(colour = guide_legend(override.aes = list(shape=c(16,NA,NA), linetype=c(0,1,1))))+
labs(x = "Time (days)", y = "Number of Infected students") +
scale_x_continuous(limits=c(0, 14), breaks=c(0,7,14)) +
scale_y_continuous(limits=c(0,400), breaks=c(0,100,200,300,400)) +
theme_bw()+theme(text = element_text(size=20))
set.seed(123)
# Set initial values:
ini_vb_3 = function(){
list(params=c(runif(1,1.9,2.1), runif(1,0.5,0.56)),
S0=runif(1,(pop-3)/pop,(pop-1)/pop),
phi=runif(1,0.9,6.1), s_sq=runif(1,0.59,3.4))
}
time.start_vb_3 <- Sys.time()
vb_fit_3=vb(m3, data = flu_data, pars = parameters_stoch, init = ini_vb_3, iter = 10000, tol_rel_obj = 0.001, seed=24176217)
time.end_vb_3 <- Sys.time()
vb_duration_3 <- time.end_vb_3 - time.start_vb_3
vb_fit_3_summary <- summary(vb_fit_3, pars = c("theta[1]", "theta[2]", "y_init[1]", "R_0", "phi", "s_sq"))$summary
print(vb_fit_3_summary,scientific=TRUE,digits=2)
print(vb_duration_3)
posts_vb_3 <-  rstan::extract(vb_fit_3)
# Model fitted values across the observed time period
fit_lambda_vb <- posts_vb_3$lambda
post_kappa_vb <- posts_vb_3$kappa
fit_kappa_vb <- unlist(post_kappa_vb)
fit_I_vb_3 <- posts_vb_3$y_hat[,,2]
fit_SIR_vb_3 <- fit_I_vb_3*pop
post_mu_vb <- log(fit_I_vb_3*pop)
fit_mu_vb <- unlist(post_mu_vb)
fit_phi_vb <- posts_vb_3$phi
fit_sigma_vb <- posts_vb_3$sigma
mean_lambda_vb <- matrix(nrow=10000, ncol=14)
mean_lambda_vb[,1]=exp(fit_mu_vb[,1]+(fit_sigma_vb/2));  # mean of Poisson parameter
for (i in 2:N){
mean_lambda_vb[,i]=exp(fit_mu_vb[,i]+(fit_kappa_vb[,i-1]- fit_mu_vb[,i])*exp(-fit_phi_vb)+(fit_sigma_vb/2));
}
median_lmean_vb = apply(mean_lambda_vb, 2, median)
low_lmean_vb = apply(mean_lambda_vb, 2, quantile, probs=c(0.025))
high_lmean_vb = apply(mean_lambda_vb, 2, quantile, probs=c(0.975))
df_fit_lmean_vb = data.frame(median_lmean_vb, low_lmean_vb, high_lmean_vb, sample_time)
load("df_I_det_Poiss_vb.Rda")  # fitted values from the deterministic model
median_I_vb<-df_fit_I_vb_1$median_I_vb_1
low_I_vb<-df_fit_I_vb_1$low_I_vb_1
high_I_vb<-df_fit_I_vb_1$high_I_vb_1
df_fit_I_vb <-data_frame(median_I_vb, low_I_vb, high_I_vb)
# Plot of the data along with the fitted mean of Poisson parameter and the fitted number of infected from the deterministic model
ggplot(df_sample_N, aes(x=sample_time, y=cases)) +
geom_ribbon(aes(x=sample_time, ymin = low_lmean_vb, ymax = high_lmean_vb), fill = "lightblue", alpha = 0.6) +
geom_ribbon(aes(x=sample_time, ymin = low_I_vb, ymax = high_I_vb), fill = "orange", alpha = 0.6) +
geom_line(data = df_fit_lmean_vb, aes(x=sample_time, y=median_lmean_vb, color="Fitted stochastic model"),size = 1.3) +
geom_line(data = df_fit_I_vb, aes(x=sample_time, y=median_I_vb, color = "Fitted deterministic model"), size = 1.3) +
geom_point(shape = 19, size = 3, (aes(color="Data"))) +
scale_colour_manual(name='', values=c('Data'='black', 'Fitted stochastic model'='lightblue4', 'Fitted deterministic model'='darkorange3'))+
guides(colour = guide_legend(override.aes = list(shape=c(16,NA,NA),linetype=c(0,1,1))))+
labs(x = "Time (days)", y = "Number of Infected students") +
scale_x_continuous(limits=c(0, 14), breaks=c(0,7,14)) +
scale_y_continuous(limits=c(0,400), breaks=c(0,100,200,300,400)) +
theme_bw() + theme(text = element_text(size=20))
functions {
real[] sir(real t, real[] y, real[] theta,
real[] x_r, int[] x_i) {
real S = y[1];
real I = y[2];
real R = y[3];
real N = x_i[1];
real beta = theta[1];
real gamma = theta[2];
real dS_dt = -beta * I * S / N;
real dI_dt =  beta * I * S / N - gamma * I;
real dR_dt =  gamma * I;
return {dS_dt, dI_dt, dR_dt};
}
}
#Coding the ODE in Stan
#real[] f(real time, real[] state, real[] theta, real[] x_r, int[] x_i)
functions {
real[] sir(real t, real[] y, real[] theta,
real[] x_r, int[] x_i) {
real S = y[1];
real I = y[2];
real R = y[3];
real N = x_i[1];
real beta = theta[1];
real gamma = theta[2];
real dS_dt = -beta * I * S / N;
real dI_dt =  beta * I * S / N - gamma * I;
real dR_dt =  gamma * I;
return {dS_dt, dI_dt, dR_dt};
}
}
y = integrate_ode_rk45(sir, y0, t0, ts, theta, x_r, x_i);
functions {
real[] sir(real t, real[] y, real[] theta,
real[] x_r, int[] x_i) {
real S = y[1];
real I = y[2];
real R = y[3];
real N = x_i[1];
real beta = theta[1];
real gamma = theta[2];
real dS_dt = -beta * I * S / N;
real dI_dt =  beta * I * S / N - gamma * I;
real dR_dt =  gamma * I;
return {dS_dt, dI_dt, dR_dt};
}
}
data {
int<lower=1> n_days;
real y0[3];
real t0;
real ts[n_days];
int N;
int cases[n_days];
}
transformed data {
real x_r[0];
int x_i[1] = { N };
}
parameters {
real<lower=0> gamma;
real<lower=0> beta;
real<lower=0> phi_inv;
}
transformed parameters{
real y[n_days, 3];
real phi = 1. / phi_inv;
{
real theta[2];
theta[1] = beta;
theta[2] = gamma;
y = integrate_ode_rk45(sir, y0, t0, ts, theta, x_r, x_i);
}
}
model {
//priors
beta ~ normal(2, 1);
gamma ~ normal(0.4, 0.5);
phi_inv ~ exponential(5);
//sampling distribution
//col(matrix x, int n) - The n-th column of matrix x. Here the number of infected people
cases ~ neg_binomial_2(col(to_matrix(y), 2), phi);
}
generated quantities {
real R0 = beta / gamma;
real recovery_time = 1 / gamma;
real pred_cases[n_days];
pred_cases = neg_binomial_2_rng(col(to_matrix(y), 2), phi);
}
generated quantities{
real R0 = beta / gamma;
real recovery_time = 1 / gamma;
real pred_cases[n_days];
pred_cases = neg_binomial_2_rng(col(to_matrix(y), 2), phi);
}
source("~/.active-rstudio-document", echo=TRUE)
source("~/.active-rstudio-document", echo=TRUE)
source("~/.active-rstudio-document", echo=TRUE)
#Data
library(outbreaks)
library(tidyverse)
theme_set(theme_bw())
ggplot(data = influenza_england_1978_school) +
geom_point(mapping = aes(x = date, y = in_bed)) +
labs(y = "Number of students in bed")
#Coding the Model: Stan Program
library(rstan)
library(gridExtra)
rstan_options (auto_write = TRUE)
options (mc.cores = parallel::detectCores ())
#Coding the ODE in Stan
#real[] f(real time, real[] state, real[] theta, real[] x_r, int[] x_i)
functions {
real switch_eta(real t, real t1, real eta, real nu, real xi) {
return(eta + (1 - eta) / (1 + exp(xi * (t - t1 - nu))));
}
real[] sir(real t, real[] y, real[] theta,
real[] x_r, int[] x_i) {
int N = x_i[1];
real tswitch = x_r[1];
real beta = theta[1];
real gamma = theta[2];
real a = theta[3];
real eta = theta[4]; // reduction in transmission rate after quarantine
real nu = theta[5]; // shift of quarantine implementation
real xi = theta[6]; // slope of quarantine implementation
real i0 = theta[7]; // initial number of infected people
real e0 = theta[8]; // initial number of infected people
real forcing_function = switch_eta(t,tswitch,eta,nu,xi); // switch function
real beta_eff = beta * forcing_function; // beta decreased to take control measures into account
real init[4] = {N - i0 - e0, e0, i0, 0}; // initial values
real S = y[1] + init[1];
real E = y[2] + init[2];
real I = y[3] + init[3];
real R = y[4] + init[4];
real dS_dt = -beta_eff * I * S / N;
real dE_dt =  beta_eff * I * S / N - a * E;
real dI_dt = a * E - gamma * I;
real dR_dt =  gamma * I;
return {dS_dt, dE_dt, dI_dt, dR_dt};
}
}
data {
int<lower=1> n_days;
real t0;
real tswitch; // date of introduction of control measures
real ts[n_days];
int N; // population size
int cases[n_days];
int t_survey_start; // antibody survey data
int t_survey_end;
int n_infected_survey;
int n_tested_survey;
}
transformed data {
int x_i[1] = { N }; //formatting to feed the ODE function
real x_r[1] = {tswitch};
}
parameters {
real<lower=0> gamma; // SEIR parameters
real<lower=0> beta;
real<lower=0> a;
real<lower=0> phi_inv;
real<lower=0,upper=1> eta; // reduction in transmission due to control measures (in proportion of beta)
real<lower=0> nu; // shift of quarantine implementation (strictly positive as it can only occur after tswitch)
real<lower=0,upper=1> xi_raw; // slope of quarantine implementation (strictly positive as the logistic must be downward)
real<lower=0> i0; // number of infected people inititally
real<lower=0> e0; // number of exposed people inititally
real<lower=0, upper=1> p_reported; // probability for an infected person to be reported (i.e counted as a case)
}
transformed parameters{
real y[n_days, 4];
real incidence[n_days - 1];
real phi = 1. / phi_inv;
real xi = xi_raw + 0.5;
real theta[8];
real<lower=0, upper=1> p_infected_survey; //proportion of people having been infected at week 5 (between 4 and 7 may)
theta = {beta, gamma, a, eta, nu, xi, i0, e0};
y = integrate_ode_rk45(sir, rep_array(0.0, 4), t0, ts, theta, x_r, x_i);
for (i in 1:n_days-1){
incidence[i] = -(y[i+1, 2] - y[i, 2] + y[i+1, 1] - y[i, 1]) * p_reported; //-(E(t+1) - E(t) + S(t+1) - S(t))
}
// mean number of infected + recovered people during week 5
p_infected_survey = mean(to_vector(y[t_survey_start:t_survey_end, 4])) / N;
}
model {
//priors
beta ~ normal(2, 1);
gamma ~ normal(0.4, 0.5);
a ~ normal(0.4, 0.5);
phi_inv ~ exponential(5);
i0 ~ normal(0, 10);
e0 ~ normal(0, 10);
p_reported ~ beta(1, 2);
eta ~ beta(2.5, 4);
nu ~ exponential(1./5);
xi_raw ~ beta(1, 1);
//sampling distribution
n_infected_survey ~ binomial(n_tested_survey, p_infected_survey); // we fit the survey data to our latent parameter
//col(matrix x, int n) - The n-th column of matrix x. Here the number of infected people
cases[1:(n_days-1)] ~ neg_binomial_2(incidence, phi);
}
generated quantities {
real R0 = beta / gamma;
real Reff[n_days]; // R0 but taking into account environmental changes
real recovery_time = 1 / gamma;
real incubation_time = 1 / a;
real pred_cases[n_days-1];
pred_cases = neg_binomial_2_rng(incidence, phi);
for (i in 1:n_days)
Reff[i] = switch_eta(i, tswitch, eta, nu, xi) * beta / gamma;
}
rstan:::rstudio_stanc("Documentos/sier.stan")
rstan:::rstudio_stanc("Documentos/sier.stan")
#Data
library(outbreaks)
library(tidyverse)
theme_set(theme_bw())
ggplot(data = influenza_england_1978_school) +
geom_point(mapping = aes(x = date, y = in_bed)) +
labs(y = "Number of students in bed")
#Coding the Model: Stan Program
library(rstan)
library(gridExtra)
rstan_options (auto_write = TRUE)
options (mc.cores = parallel::detectCores ())
#Coding the ODE in Stan
#real[] f(real time, real[] state, real[] theta, real[] x_r, int[] x_i)
functions {
real switch_eta(real t, real t1, real eta, real nu, real xi) {
return(eta + (1 - eta) / (1 + exp(xi * (t - t1 - nu))));
}
real[] sir(real t, real[] y, real[] theta,
real[] x_r, int[] x_i) {
int N = x_i[1];
real tswitch = x_r[1];
real beta = theta[1];
real gamma = theta[2];
real a = theta[3];
real eta = theta[4]; // reduction in transmission rate after quarantine
real nu = theta[5]; // shift of quarantine implementation
real xi = theta[6]; // slope of quarantine implementation
real i0 = theta[7]; // initial number of infected people
real e0 = theta[8]; // initial number of infected people
real forcing_function = switch_eta(t,tswitch,eta,nu,xi); // switch function
real beta_eff = beta * forcing_function; // beta decreased to take control measures into account
real init[4] = {N - i0 - e0, e0, i0, 0}; // initial values
real S = y[1] + init[1];
real E = y[2] + init[2];
real I = y[3] + init[3];
real R = y[4] + init[4];
real dS_dt = -beta_eff * I * S / N;
real dE_dt =  beta_eff * I * S / N - a * E;
real dI_dt = a * E - gamma * I;
real dR_dt =  gamma * I;
return {dS_dt, dE_dt, dI_dt, dR_dt};
}
}
data {
int<lower=1> n_days;
real t0;
real tswitch; // date of introduction of control measures
real ts[n_days];
int N; // population size
int cases[n_days];
int t_survey_start; // antibody survey data
int t_survey_end;
int n_infected_survey;
int n_tested_survey;
}
transformed data {
int x_i[1] = { N }; //formatting to feed the ODE function
real x_r[1] = {tswitch};
}
parameters {
real<lower=0> gamma; // SEIR parameters
real<lower=0> beta;
real<lower=0> a;
real<lower=0> phi_inv;
real<lower=0,upper=1> eta; // reduction in transmission due to control measures (in proportion of beta)
real<lower=0> nu; // shift of quarantine implementation (strictly positive as it can only occur after tswitch)
real<lower=0,upper=1> xi_raw; // slope of quarantine implementation (strictly positive as the logistic must be downward)
real<lower=0> i0; // number of infected people inititally
real<lower=0> e0; // number of exposed people inititally
real<lower=0, upper=1> p_reported; // probability for an infected person to be reported (i.e counted as a case)
}
transformed parameters{
real y[n_days, 4];
real incidence[n_days - 1];
real phi = 1. / phi_inv;
real xi = xi_raw + 0.5;
real theta[8];
real<lower=0, upper=1> p_infected_survey; //proportion of people having been infected at week 5 (between 4 and 7 may)
theta = {beta, gamma, a, eta, nu, xi, i0, e0};
y = integrate_ode_rk45(sir, rep_array(0.0, 4), t0, ts, theta, x_r, x_i);
for (i in 1:n_days-1){
incidence[i] = -(y[i+1, 2] - y[i, 2] + y[i+1, 1] - y[i, 1]) * p_reported; //-(E(t+1) - E(t) + S(t+1) - S(t))
}
// mean number of infected + recovered people during week 5
p_infected_survey = mean(to_vector(y[t_survey_start:t_survey_end, 4])) / N;
}
model {
//priors
beta ~ normal(2, 1);
gamma ~ normal(0.4, 0.5);
a ~ normal(0.4, 0.5);
phi_inv ~ exponential(5);
i0 ~ normal(0, 10);
e0 ~ normal(0, 10);
p_reported ~ beta(1, 2);
eta ~ beta(2.5, 4);
nu ~ exponential(1./5);
xi_raw ~ beta(1, 1);
//sampling distribution
n_infected_survey ~ binomial(n_tested_survey, p_infected_survey); // we fit the survey data to our latent parameter
//col(matrix x, int n) - The n-th column of matrix x. Here the number of infected people
cases[1:(n_days-1)] ~ neg_binomial_2(incidence, phi);
}
generated quantities {
real R0 = beta / gamma;
real Reff[n_days]; // R0 but taking into account environmental changes
real recovery_time = 1 / gamma;
real incubation_time = 1 / a;
real pred_cases[n_days-1];
pred_cases = neg_binomial_2_rng(incidence, phi);
for (i in 1:n_days)
Reff[i] = switch_eta(i, tswitch, eta, nu, xi) * beta / gamma;
}
rstan:::rstudio_stanc("Documentos/sir_example.stan")
library(deSolve)
library(dplyr)
library(rstan)
library(outbreaks)
library(bayesplot)
rstan_options(auto_write = TRUE)
options(mc.cores = parallel::detectCores())
rstan:::rstudio_stanc("Documentos/sir_example.stan")
setwd("~/Documentos/TYLCVD-fit")
library(deSolve)
library(dplyr)
library(rstan)
library(outbreaks)
library(bayesplot)
library(tidyverse)
library(gridExtra)
library(deSolve)
library(dplyr)
library(rstan)
library(outbreaks)
library(bayesplot)
library(tidyverse)
library(gridExtra)
rstan_options(auto_write = TRUE)
options(mc.cores = parallel::detectCores())
df_PSCL4 <- read_csv("datos_circle.csv")
cases <- df_PSCL4$infected
days <- df_PSCL4$t
theme_set(theme_bw())
ggplot(data = df_PSCL4) +
geom_point(mapping = aes(x = days, y = cases)) +
labs(y = "Number of infected plants")
###############################################
N = length(days) # Number of days observed throughout the outbreak
pop = 1000         # Population
sample_time=1:N
# Modify data into a form suitable for Stan
tomato_data = list(n_obs = N,
n_theta = 9,
n_difeq = 6,
n_pop = pop,
y = cases,
t0 = 0,
ts = sample_time)
# Specify parameters to monitor
parameters = c("y_hat", "b",  "R0")
m1 <- stan_model("Tomato_sys2.stan")
### Fit and sample from the posterior using Hamiltonian Monte Carlo-NUTS:
n_chains=4
n_warmups=500
n_iter=2000
n_thin=50
set.seed(1234)
# Set initial values:
ini_1 = function(){
list(theta=c(0.1,0.01, 0.01,0.075, 0.01,  0.06, 0.06, 0.4, 1.0))
}
time.start_nuts1 <- Sys.time()
nuts_fit_1 = sampling(m1,
data = tomato_data,
pars = parameters,
init = ini_1,
chains = n_chains,
warmup = n_warmups,
iter = n_iter,
thin=n_thin,
seed=0)
time.end_nuts1 <- Sys.time()
duration_nuts1<- time.end_nuts1 - time.start_nuts1
