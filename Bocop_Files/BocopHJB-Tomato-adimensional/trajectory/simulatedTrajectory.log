**************************** 
*****    DEFINITION    ***** 
**************************** 

# This file defines all dimensions and parameters for your problem: 
# Dimensions:
state.dimension 5
control.dimension 3
constant.dimension 12
brownian.dimension 2

# Variable Names :
state.0 Sp
state.1 Lp
state.2 Ip
state.3 Sv
state.4 Iv
control.0 u1
control.1 u2
control.2 u3

# Constants :
constant.0 betap 0.1
constant.1 r1 0.01
constant.2 r2 0.01
constant.3 b 0.075
constant.4 betav 0.01
constant.5 gamma 0.03
constant.6 gammaf 0.03
constant.7 theta 0.4
constant.8 mu 1
constant.9 sigmaL 0.118417
constant.10 sigmaI 0.990762
constant.11 sigmaV 0.652238

# Time discretization :
time.initial 0
time.final 20
time.steps 200

# State discretization: uniform grid
state.0.lowerbound 0
state.0.upperbound 1
state.0.steps 1
state.1.lowerbound 0
state.1.upperbound 1
state.1.steps 1
state.2.lowerbound 0
state.2.upperbound 1
state.2.steps 1
state.3.lowerbound 0
state.3.upperbound 1
state.3.steps 1
state.4.lowerbound 0
state.4.upperbound 1
state.4.steps 1

# value function for points outside the state grid:
# final cost ; projection; infinity; user_function
valueFunction.out.of.grid infinity

# Control discretisation :
# uniform ; 
# components_user_file; components_user_function; control_set_user_file;
# control_set_user_function; control_set_user_function_state_dependent
control.set uniform
# uniform case 
control.0.lowerbound 0
control.0.upperbound 0.35
control.0.steps 5
control.1.lowerbound 0
control.1.upperbound 0.25
control.1.steps 5
control.2.lowerbound 0
control.2.upperbound 0.6
control.2.steps 5

# System modes (>=1) and admissible transitions for switching between modes
# all_transitions; user_file; user_function
# state jumps at transitions: none; user_function
system.modes 1
admissible.transitions all_transitions
state.jumps none

# Value function save files:
# Previous steps type: resume; overwrite; ask
# Output format type: text; binary; none
# Output path: . --> here; other repertoire
valueFunction.previous.steps overwrite
valueFunction.output.format text
valueFunction.output.path valueFunction/

# SimulatedTrajectory: 
# Computation: none; after_valueFunction; read_valueFunction
# Noise: none; gaussian; user_function
# Starting mode: best_mode; user_function; value:[0, nbmode-1]
# Output path: . -->here; other repertoire
simulatedTrajectory.computation after_valueFunction
simulatedTrajectory.output.path trajectory/
simulatedTrajectory.noise gaussian
simulatedTrajectory.starting.mode 0
simulatedTrajectory.starting.state.0 0.65
simulatedTrajectory.starting.state.1 0.25
simulatedTrajectory.starting.state.2 0.1
simulatedTrajectory.starting.state.3 0.5
simulatedTrajectory.starting.state.4 0.5

# ProcessLaw: 
# Computation: true; false
# Output Path: . -->here; other repertoire
processLaw.computation false
processLaw.output.path processLaw/
processLaw.initial.path processLaw/initialDistribution/




***************************** 
*** TRAJECTORY SIMULATION *** 
***************************** 

Objective value (from value function): 1.98165e+019 and simulated: 4.53885
(running cost: 4.53885, switching cost: 0 and final cost: 0)

grad(V)(x0,t0) estimations
Centered: 0
Downwind: 0
Upwind  : 0

Time spent to simulate optimal trajectory: 6.704 s
Time spent to save the trajectory: 0.00799998 s

